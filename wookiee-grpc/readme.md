# wookiee-grpc 

## Install
wookiee-grpc is available for Scala 2.12 and 2.13. There are no plans to support scala 2.11 or lower.
```scala
libraryDependencies += "com.oracle.infy.wookiee" %% "wookiee-grpc" % "0.0.1-SNAPSHOT"
```

## Setup ScalaPB
We use [ScalaPB](https://github.com/scalapb/ScalaPB) to generate source code from a `.proto` file. You can use
other plugins/code generators if you wish. wookiee-grpc will work as long as you have `io.grpc.ServerServiceDefinition`
for the server and something that accept `io.grpc.ManagedChannel` for the client.

Declare your gRPC service using proto3 syntax and save it in `src/main/protobuf/myService.proto`
```proto
syntax = "proto3";

package com.oracle.infy.wookiee;

message HelloRequest {
  string name = 1;
}

message HelloResponse {
  string resp = 1;
}

service MyService {
  rpc greet(HelloRequest) returns (HelloResponse) {}
}

```

Add ScalaPB plugin to `plugin.sbt` file
```sbt
addSbtPlugin("com.thesamet" % "sbt-protoc" % "0.99.34")
libraryDependencies += "com.thesamet.scalapb" %% "compilerplugin" % "0.10.8"

```

Configure the project in `build.sbt` so that ScalaPB can generate code
```sbt
    libraryDependencies ++= Seq(
      "io.grpc" % "grpc-netty" % scalapb.compiler.Version.grpcJavaVersion,
      "com.thesamet.scalapb" %% "scalapb-runtime-grpc" % scalapb.compiler.Version.scalapbVersion
    ),
    PB.targets in Compile := Seq(
      scalapb.gen() -> (sourceManaged in Compile).value
    ),

```

In the sbt shell, type `protocGenerate` to generate scala code based on the `.proto` file. ScalaPB will generate
code and put it under `target/scala-2.13/src_managed/main`.

## Using wookiee-grpc
After the code has been generated by ScalaPB, you can use wookiee-grpc for service discoverability and load balancing.

```scala
import com.oracle.infy.wookiee.grpc.{WookieeGrpcChannel, WookieeGrpcServer}
import com.oracle.infy.wookiee.model.Host
// Note: This is generated code from `src/main/protobuf/myService.proto`
import com.oracle.infy.wookiee.myService.MyServiceGrpc.MyService
import com.oracle.infy.wookiee.myService.{HelloRequest, HelloResponse, MyServiceGrpc}
import io.grpc.ServerServiceDefinition

import scala.concurrent.duration._
import scala.concurrent.{ExecutionContext, Future}

object Example {

  def main(args: Array[String]): Unit = {
    val dispatcherThreads = 2
    val mainECThreads = 4

    val dispatcherEC = ExecutionContext.global
    val blockingEC = ExecutionContext.global
    implicit val mainEC: ExecutionContext = ExecutionContext.global

    val zookeeperDiscoveryPath = "/discovery"

    // This is just to demo, use an actual Zookeeper quorum.
//    val zkFake = new TestingServer()
//    val connStr = zkFake.getConnectString
    val connStr = "localhost:2181"

    val ssd: ServerServiceDefinition = MyService.bindService(new MyService {
      override def greet(request: HelloRequest): Future[HelloResponse] =
        Future.successful(HelloResponse(s"Hello ${request.name}"))
    }, blockingEC)

    val serverF: Future[WookieeGrpcServer] = WookieeGrpcServer.startUnsafe(
      zookeeperQuorum = connStr,
      discoveryPath = zookeeperDiscoveryPath,
      zookeeperRetryInterval = 3.seconds,
      zookeeperMaxRetries = 20,
      serverServiceDefinition = ssd,
      port = 9091,
      // This is an optional arg. wookiee-grpc will try to resolve the address automatically.
      // If you are running this locally, its better to explicitly set the hostname
      localhost = Host(0, "localhost", 9091, Map.empty),
      dispatcherExecutionContext = dispatcherEC,
      mainExecutionContext = mainEC,
      blockingExecutionContext = blockingEC,
      dispatcherExecutionContextThreads = dispatcherThreads,
      mainExecutionContextThreads = mainECThreads
    )

    val channel = WookieeGrpcChannel.unsafeOf(
      zookeeperQuorum = connStr,
      serviceDiscoveryPath = zookeeperDiscoveryPath,
      zookeeperRetryInterval = 3.seconds,
      zookeeperMaxRetries = 20,
      grpcChannelThreadLimit = dispatcherThreads,
      dispatcherExecutionContext = dispatcherEC,
      mainExecutionContext = mainEC,
      blockingExecutionContext = blockingEC
    )

    val stub: MyServiceGrpc.MyServiceStub = MyServiceGrpc.stub(
      channel
    )

    def helloResponseF: Future[HelloResponse] =  {
      for {
        server <- serverF
        resp <- stub.greet(HelloRequest("world!"))
        _ <- server.shutdownUnsafe()
      } yield resp
    }

    val _ = () => helloResponseF

  }
}
```
